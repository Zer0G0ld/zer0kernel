# x86-64 
Este artigo discute x86-64 CPUs (AMD64 e equivalentes da Intel EM64T implementação). IA-64 (Itânio) é **realmente** uma fera diferente e não abordada aqui.

**Indice:**
1. Características
    1.1 Modo Longo
    1.2 Segmentação em Modo Longo
    1.3 Mais informações
2. Configurando
    2.1 Como posso detectar se a CPU tem 64 bits?
    2.2 Como habilito o Modo Longo?
    2.3 Existem restrições ao código de 32 bits em exceução no Modo Legado?
    2.4 Entrando diretamente no Modo Longo
    2.5 Notificando o BIOS
3. Modelos de ambiente de 64 bits
    3.1 Tipos de dados
    3.2 Modelos usados por sistemas operacionais de 64 bits
    3.3 Tipos de segmentos de texto

---

Características
Modo Longo
O modo longo estende os registradores gerais para 64 bits (RAX, RBX, RIP, RSP, RFLAGS, etc.) e adiciona oito registradores inteiros adicionais (R8, R9, ..., R15) mais oito registradores SSE (XMM8 a XMM15) à CPU. Os endereços lineares são estendidos para 64 bits (no entanto, uma determinada CPU pode implementar menos que isso) e o espaço de endereço físico é estendido para 52 bits (uma determinada CPU pode implementar menos que isso). Em essência, o modo longo adiciona outro modo à CPU.

O modo longo não suporta comutação de tarefas de hardware ou tarefas virtuais 8086. No modo longo, o CS atual determina se o código em execução no momento é um código de 64 bits (modo longo verdadeiro) ou um código de 32 bits (modo de compatibilidade), ou mesmo um código de modo protegido de 16 bits (ainda no modo de compatibilidade). O uso de paginação tornou-se obrigatório e a segmentação foi reduzida por razões de desempenho.

As primeiras CPUs de 64 bits da Intel e da AMD suportam endereços físicos de 40 bits e endereços lineares de 48 bits.

Segmentação em Modo Longo
Segmentação em funções de modo longo com um modelo plano, com exceção de dois registradores: FS e GS. Definir o endereço base para esses dois registradores de segmento é possível por meio de dois registros específicos Registro Específico de Modelo (MSR), FS.base (C000_0100h) e GS.base (C000_0101h).

Além disso, há uma instrução específica de modo longo chamada TROCAS, que troca o conteúdo do GS.base e outro MSR chamado KernelGSBase (C000_0102h). Esta instrução é particularmente útil para preservar informações do kernel para um núcleo de processador lógico específico em trocas de contexto. Nota: Esta é uma operação de troca.

Mais informações
Esta visão geral dos recursos está incompleta. Por favor, veja o [Artigo da Wikipédia sobre x86-64] para mais informações.

Configurando
Como posso detectar se a CPU tem 64 bits?
Depois de chamar CPUID com EAX=0x80000001, todos os processadores compatíveis com AMD64 têm o bit compatível com modo longo ativado nos sinalizadores de recursos estendidos (bit 29) no EDX. Existem também outros bits exigidos pelo modo longo; você pode verificá-los nos documentos CPUID no Referência de instrução de uso geral da AMD (Link inativo, o autor original provavelmente quis dizer "Manual do Programador de Arquitetura AMD64 Volume 3: Instruções de Uso Geral e Sistema", encontrado aqui: http://developer.amd.com/resources/developer-guides-manuals/)

Como habilito o Modo Longo?
As etapas para habilitar o modo longo são:

Desativar paginação
Defina o bit de habilitação do PAE no CR4
Carregue CR3 com o endereço físico do PML4 (Mapa de páginas de nível 4)
Habilite o modo longo definindo o sinalizador LME (bit 8) em MSR 0xC0000080 (também conhecido como EFER)
Habilitar paginação
Referência: Manual do desenvolvedor de software Intel 64 e IA-32 Architectures, Seção 9.8.5

Agora a CPU estará no modo de compatibilidade e as instruções ainda serão de 32 bits. Para entrar no modo longo, o bit D/B (bit 22, 2o valor de 32 bits) do segmento de código GDT deve estar limpo (como seria para um segmento de código de 16 bits) e o bit L (bit 21, 2o valor de 32 bits) do segmento de código GDT deve ser definido. Feito isso, a CPU fica no modo longo de 64 bits.

Existem restrições ao código de 32 bits em execução no Modo Legado?
Os processadores x86-64 podem operar em modo legado, ainda iniciam em modo real e o modo protegido de 16 e 32 bits ainda está disponível (junto com o modo Virtual 8086 associado). Isso significa que um sistema operacional x86, mesmo o DOS, ainda funcionará perfeitamente. A única diferença é que os endereços físicos podem ter até 52 bits (ou tantos bits quantos forem implementados pela CPU) quando o PAE é usado.

No entanto, Modo Virtual 8086 não existe no modo longo/compatibilidade.

Se você estiver executando em um sistema multiprocessador, poderá enviar a um processador um IPI STARTUP para um endereço de memória de modo real (consulte a especificação Intel MultiProcessor para obter mais detalhes) que carrega um programa de modo real. O principal problema com essa abordagem é que ela depende da presença de vários processadores no sistema.

Entrando diretamente no Modo Longo
O modo protegido deve ser inserido antes de ativar o modo longo. Um ambiente mínimo de modo protegido deve ser estabelecido para permitir que a inicialização em modo longo ocorra. Este ambiente deve incluir o seguinte:

Um IDT de modo protegido para vetorizar interrupções e exceções aos manipuladores apropriados enquanto estiver no modo protegido.
Os manipuladores de interrupção e exceção de modo protegido referenciados pelo IDT.
Os descritores de porta para cada manipulador devem ser carregados no IDT.
--Documentos AMD64, volume 2, seção 14.4 (Habilitando o Modo Protegido), 24593 Rev. 3.10 de fevereiro de 2005
Dito isto, temos um tópico onde Brendan mostra como habilitar o modo longo de 64 bits sem IDT de 32 bits e sem segmentos de 32 bits - tenha certeza, no entanto, de que qualquer exceção relacionada à paginação que ocorra no modo longo antes de habilitar o IDT de 64 bits fará com que o processador reinicie devido a uma falha tripla.

Há também um exemplo disso implementado em a carregador de inicialização.

Notificando o BIOS
Para que o firmware integrado ao sistema se otimize para execução no Modo Longo, a AMD recomenda que o sistema operacional notifique o BIOS sobre o ambiente de destino pretendido no qual o sistema operacional será executado: modo de 32 bits, modo de 64 bits ou uma mistura de ambos os modos. Isso pode ser feito chamando a interrupção do BIOS 15h do Modo Real com AX definido como 0xEC00 e BL definido como 1 para o Modo Protegido de 32 bits, 2 para o Modo Longo de 64 bits ou 3 se ambos os modos forem usados.

Modelos de ambiente de 64 bits
Existem três modelos de programação de 64 bits que você precisa considerar: LP64, ILP64, LLP64. Cada modelo tem suas próprias armadilhas. I/L/P significam Int, Long, Pointer, respectivamente; 64 é o número de bits em cada um.

LP64 significa Longs (e Long Longs) e Pointers têm 64 bits de largura, Ints têm 32 bits de largura. LLP64 significa que Long Longs e Pointers têm 64 bits de largura, Longs e Ints têm 32 bits de largura. ILP64 significa que Ints, Longs (e Long Longs) e Pointers têm 64 bits de largura.

A maioria dos *nixes usa o modelo LP64, o Windows usa a convenção LLP64. ILP64 é usado muito raramente.

Tipos de dados
Esta tabela lista a repartição dos tamanhos nos vários modelos de programação.

Tipo de dados	LP64	ILP64	LLP64	ILP32	LP32
char	8	8	8	8	8
curto	16	16	16	16	16
_int	32	--	32	--	--
int	32	64	32	32	16
longo	64	64	32	32	32
longo longo	--	--	64	--	--
ponteiro	64	64	64	32	32
Modelos usados por sistemas operacionais de 64 bits
A tabela a seguir lista o que alguns sistemas operacionais atuais de 64 bits têm como modelo de programação.

SO	Modo
Windows XP X64	LLP64
Linux	LP64
FreeBSD/OpenBSD	LP64
Solaris	LP64
DEC OSF/1 Alfa	LP64
SGI Irix	LP64
HP UX 11	LP64
Tipos de segmentos de texto
Outra coisa que você deve ter em mente é que, embora o espaço de endereço (e com ele todos os ponteiros) tenha 64 bits de largura, o código gerado no segmento de texto provavelmente não tem. Isso ocorre porque, por padrão, o gcc compila para a instrução "mov", que tem apenas 32 bits imediatos. Isso significa que programas de 64 bits são limitados a 2G, assim como programas no modo de 32 bits.

Se você já viu uma mensagem de erro como esta:

realocação truncada para caber: R_X86_64_32 contra símbolo
então seu código atingiu essa barreira. Para Assembly, você deve usar a instrução "movabs" em vez de "mov", e para gcc você precisa selecionar um modelo de segmento de texto diferente com o argumento "-mcmodel".

Bandeira	Endereçamento de segmento de texto
-mcmodel=pequeno	O programa e seus símbolos devem estar vinculados nos 2 GB inferiores do espaço de endereço (este é o modelo padrão)
-mcmodel=grande	Este modelo não faz suposições sobre endereços e tamanhos de seções.
-mcmodel=médio	O programa está vinculado nos 2 GB inferiores do espaço de endereço. Pequenos símbolos também são colocados lá. Símbolos com tamanhos maiores que -mlarge-data-threshold são colocados em grandes seções de dados ou bss e podem estar localizados acima de 2 GB.
-mcmodel=kernel	O kernel é executado nos 2 GB negativos do espaço de endereço. Este modelo deve ser usado para código do kernel Linux.
Vale ressaltar que os modelos de código são diferentes para arquiteturas, pois estão vinculados à codificação de instruções. Por exemplo, AArch64 também tem um "-mcmodel=tiny", que permite endereçamento 1M, desconhecido para x86_64. E para AArch64 "-mcmodel=small" tem uma limitação 4G, não 2G como para x86_64.

Computação de 64 bits

Artigo
Falar
Ler
Editar
Ver histórico

Ferramentas
Aparência esconder
Texto

Pequeno

Padrão

Grande
Largura

Padrão

Largo
Cor (beta)

Automático

Luz

Escuro
Da Wikipedia, a enciclopédia gratuita
"64 bits" redireciona aqui. Para imagens de 64 bits em computação gráfica, consulte Cor profunda.
ícone
Este artigo precisa de citações adicionais para verificação. Por favor ajude melhore este artigo por adicionando citações a fontes confiáveis. Material sem fonte pode ser contestado e removido.
Encontre fontes: "Computação de 64 bits" – notícias · jornais · livros · estudioso · JSTOR (Abril de 2023) (Saiba como e quando remover esta mensagem)
Larguras de bits de arquitetura de computador
Pedaço
14812161824263031323645486064128256512fatiamento de bits
Aplicação
8163264
Ponto flutuante binário precisão
16 (×½)2432 (×1)4064 (×2)80128 (×4)256 (×8)
Ponto flutuante decimal precisão
3264128
vte

Despejo hexadecimal da tabela de seções em 64 bits Executável portátil Arquivo. Um 64 bits palavra pode ser expresso como uma sequência de 16 hexadecimal dígitos.
Em arquitetura de computadores, 64 bits inteiros, endereços de memória, ou outro dados unidades[um] são aqueles que têm 64 anos pedaços largo. Além disso, 64 bits unidades centrais de processamento (CPU) e unidades lógicas aritméticas (ALU) são aqueles que se baseiam em registradores do processador, ônibus de endereço, ou barramentos de dados desse tamanho. Um computador que usa tal processador é um computador de 64 bits.

Do ponto de vista do software, computação de 64 bits significa o uso de código de máquina com 64 bits memória virtual endereços. No entanto, nem todos os conjuntos de instruções de 64 bits suportam endereços completos de memória virtual de 64 bits; x86-64 e AArch64, por exemplo, suportam apenas 48 bits de endereço virtual, com os 16 bits restantes do endereço virtual precisando ser todos zeros (000...) ou todos uns (111...), e vários conjuntos de instruções de 64 bits suportam menos de 64 bits de endereço de memória física.

O termo 64 bits também descreve uma geração de computadores em que processadores de 64 bits são a norma. 64 bits é um palavra tamanho que define certas classes de arquitetura de computador, barramentos, memória e CPUs e, por extensão, o software que roda neles. CPUs de 64 bits têm sido usadas em supercomputadores desde os anos 70 (Cray-1, 1975) e em computadores com conjunto de instruções reduzido (RISC) baseado estações de trabalho e servidores desde o início da década de 1990. Em 2003, CPUs de 64 bits foram introduzidas no mainstream PC mercado na forma de processadores x86-64 e o PowerPC G5.

Um registro de 64 bits pode conter qualquer um dos 264 (acima de 18 anos quintilhão ou 1,8×1019) valores diferentes. O alcance de inteiro os valores que podem ser armazenados em 64 bits dependem do representação inteira usado. Com as duas representações mais comuns, o intervalo é de 0 a 18.446.744.073.709.551.615 (igual a 264 − 1) para representação como um (não assinado) número binário, e −9.223.372.036.854.775.808 (−263) até 9.223.372.036.854.775.807 (263 − 1) para representação como complemento de dois. Portanto, um processador com endereços de memória de 64 bits pode acessar diretamente 264 bytes (16 exabytes ou EB) de endereçável por byte memória.

Sem qualificação adicional, a Arquitetura de computador de 64 bits geralmente tem número inteiro e endereçamento registros que têm 64 bits de largura, permitindo suporte direto para tipos de dados e endereços de 64 bits. No entanto, uma CPU pode ter externo barramentos de dados ou ônibus de endereço com tamanhos diferentes dos registradores, ainda maiores (os de 32 bits Pentium tinha um barramento de dados de 64 bits, por exemplo).[1]

Implicações arquitetônicas
ícone
Esta seção não citar qualquer fontes. Por favor ajude melhore esta seção por adicionando citações a fontes confiáveis. Material sem fontes pode ser contestado e removido. (Abril de 2023) (Saiba como e quando remover esta mensagem)
Os registros do processador são normalmente divididos em vários grupos: inteiro, ponto flutuante, instrução única, vários dados (SIM), controlar, e muitas vezes registros especiais para aritmética de endereços que podem ter vários usos e nomes, como endereço, índice, ou registros de base. No entanto, em projetos modernos, essas funções são frequentemente executadas por propósitos mais gerais inteiroregistros. Na maioria dos processadores, apenas registros inteiros ou de endereço podem ser usados para endereçar dados na memória; os outros tipos de registros não podem. O tamanho desses registradores, portanto, normalmente limita a quantidade de memória diretamente endereçável, mesmo que existam registradores, como registradores de ponto flutuante, que sejam mais largos.

A maioria dos processadores de alto desempenho de 32 e 64 bits (algumas exceções notáveis são mais antigos ou incorporados Arquitetura ARM (ARM) e 32 bits Arquitetura MIPS CPUs (MIPS)) têm hardware de ponto flutuante integrado, que geralmente, mas nem sempre, é baseado em unidades de dados de 64 bits. Por exemplo, embora o x86/x87 a arquitetura possui instruções capazes de carregar e armazenar valores de ponto flutuante de 64 bits (e 32 bits) na memória, os dados internos de ponto flutuante e o formato de registro têm 80 bits de largura, enquanto os registros de uso geral têm 32 bits de largura. Em contraste, o de 64 bits Alfa a família usa um formato de dados e registros de ponto flutuante de 64 bits e registros inteiros de 64 bits.

História
Muitos computadores conjuntos de instruções são projetados para que um único registro inteiro possa armazenar o endereço de memória para qualquer local físico ou do computador memória virtual. Portanto, o número total de endereços na memória é frequentemente determinado pela largura desses registros. O IBM Sistema/360 da década de 1960 era um dos primeiros computadores de 32 bits; tinha registradores inteiros de 32 bits, embora usasse apenas os 24 bits de ordem inferior de uma palavra para endereços, resultando em um 16 MiB (16 × 10242 bytes) espaço de endereço. 32 bits superminicomputadores, como o DEZ VACINA, tornou-se comum na década de 1970, e microprocessadores de 32 bits, como o Família Motorola 68000 e o Membros de 32 bits da família x86 começando com o Intel 80386, apareceu em meados da década de 1980, tornando 32 bits uma espécie de de facto consenso como um tamanho de registro conveniente.

Um 32 bits registro de endereço significava que 232 endereços, ou 4 GB de memória de acesso aleatório (RAM), poderia ser referenciado. Quando estas arquiteturas foram concebidas, 4 GB de memória estavam tão além das quantidades típicas (4 MiB) nas instalações, que isto foi considerado suficiente margem de manobra para endereçamento. 4,29 bilhões de endereços foram considerados um tamanho apropriado para trabalhar por outro motivo importante: 4,29 bilhões de números inteiros são suficientes para atribuir referências exclusivas à maioria das entidades em aplicativos como bases de dados.

Alguns supercomputador arquiteturas das décadas de 1970 e 1980, como a Cray-1,[2] usavam registradores de até 64 bits de largura e suportavam aritmética de inteiros de 64 bits, embora não suportassem endereçamento de 64 bits. Em meados dos anos 80, Intel i860[3] o desenvolvimento começou culminando em um lançamento em 1989; o i860 tinha registradores inteiros de 32 bits e endereçamento de 32 bits, portanto não era um processador totalmente de 64 bits, embora sua unidade gráfica suportasse aritmética inteira de 64 bits.[4] Entretanto, 32 bits continuaram sendo a norma até o início da década de 1990, quando as reduções contínuas no custo da memória levaram a instalações com quantidades de RAM próximas a 4 GB, e o uso de espaços de memória virtual que excediam o teto de 4 GB se tornou desejável para lidar com certos tipos de problemas. Em resposta, MIPS e DEC desenvolveram arquiteturas de microprocessadores de 64 bits, inicialmente para ponta estação de trabalho e servidor máquinas. Em meados dos anos 90, Sistemas de Computador HAL, Microsistemas solares, IBM, Gráficos de Silício, e Hewlett-Packard desenvolveram arquiteturas de 64 bits para seus sistemas de estação de trabalho e servidor. Uma exceção notável a esta tendência foi mainframes da IBM, que então usava dados de 32 bits e endereços de 31 bits; os mainframes da IBM não incluíam processadores de 64 bits até 2000. Durante a década de 1990, vários microprocessadores de 64 bits de baixo custo foram usados em eletrônicos de consumo e aplicações embarcadas. Notavelmente, o Nintendo 64[5] e o PlayStation 2 tinha microprocessadores de 64 bits antes de sua introdução em computadores pessoais. Impressoras de última geração, equipamentos de rede e computadores industriais também usavam microprocessadores de 64 bits, como o Dispositivos de efeito quântico R$ 5.000.[6] A computação de 64 bits começou a chegar ao desktop do computador pessoal a partir de 2003, quando alguns modelos em MaçãAs linhas do Macintosh mudaram para PowerPC 970 processadores (denominados G5 pela Apple), e Microdispositivos avançados (AMD) lançou seu primeiro 64 bits x86-64 processador. A memória física acabou alcançando os limites de 32 bits. Em 2023, os laptops eram comumente equipados com 16 GB e servidores a partir de 64 GB de memória,[7] excedendo em muito a capacidade de endereço de 4 GB de 32 bits.

Linha do tempo de dados de 64 bits
1961
A IBM entrega o IBM 7030 Stretch supercomputador, que usa palavras de dados de 64 bits e palavras de instrução de 32 ou 64 bits.
1974
Corporação de Dados de Controle lança o CDC Estrela-100 supercomputador vetorial, que usa uma arquitetura de palavras de 64 bits (os sistemas CDC anteriores eram baseados em uma arquitetura de 60 bits).
Computadores Internacionais Limitados lança o Série ICL 2900 com 32 bits, 64 bits e 128 bits complemento de dois inteiros; ponto flutuante de 64 bits e 128 bits; decimal compactado de 32 bits, 64 bits e 128 bits e um registrador acumulador de 128 bits. A arquitetura sobreviveu através de uma sucessão de máquinas ICL e Fujitsu. O mais recente é o Fujitsu Supernova, que emula o ambiente original em processadores Intel de 64 bits.
1976
Pesquisa Cray entrega o primeiro Cray-1 supercomputador, que é baseado em uma arquitetura de palavras de 64 bits e formará a base para os supercomputadores vetoriais Cray posteriores.
1983
Elxsi lança o paralelo Elxsi 6400 minissupercomputador. A arquitetura Elxsi possui registradores de dados de 64 bits, mas um espaço de endereço de 32 bits.
1989
Intel apresenta o Intel i860 computador com conjunto de instruções reduzido Processador (RISC). Comercializado como um "microprocessador de 64 bits", ele tinha essencialmente uma arquitetura de 32 bits, aprimorada com uma unidade gráfica 3D capaz de operações inteiras de 64 bits.[8]
1993
Atari apresenta o Atari Jaguar console de videogame, que inclui alguns caminhos de dados de 64 bits de largura em sua arquitetura.[9]
Linha do tempo de endereço de 64 bits
1991
Sistemas de Computador MIPS produz o primeiro microprocessador de 64 bits, o R4000, que implementa o MIPS III arquitetura, a terceira revisão de sua Arquitetura MIPS.[10] A CPU é usada em SGI estações de trabalho gráficas começando com o IRIS Carmesim. Pesquisa da Praça Kendall entregar seu primeiro supercomputador KSR1, baseado em uma arquitetura proprietária de processador RISC de 64 bits em execução OSF/1.
1992
Corporação de Equipamentos Digitais (DEC) apresenta o puro 64 bits Alfa arquitetura que nasceu da PRISMA projeto.[11]
1994
Intel anuncia planos para o 64 bits IA-64 arquitetura (desenvolvida em conjunto com Hewlett-Packard) como sucessor de seus 32 bits IA-32 processadores. A data de lançamento prevista era de 1998 a 1999.
1995
Sol lança um 64 bits SPARC processador, o UltraSPARC.[12] Fujitsu-propriedade Sistemas de Computador HAL lança estações de trabalho baseadas em uma CPU de 64 bits, a primeira geração projetada de forma independente da HAL SPARC64. A IBM lança os microprocessadores A10 e A30, os primeiros processadores PowerPC AS de 64 bits.[13] A IBM também lança uma atualização de sistema AS/400 de 64 bits, que pode converter o sistema operacional, o banco de dados e os aplicativos.
1996
Nintendo apresenta o Nintendo 64 console de videogame, construído em torno de uma variante de baixo custo do MIPS R4000. HP lança a primeira implementação de seu 64 bits PA-RISC 2.0 arquitetura, o PA-8000.[14]
1998
IBM lança o POTÊNCIA3 linha de PowerPC/ de 64 bits completosPODER processadores.[15]
1999
Intel lança o conjunto de instruções para o IA-64 arquitetura. DMAE divulga publicamente seu conjunto de extensões de 64 bits para IA-32, chamadas x86-64 (mais tarde denominado AMD64).
2000
IBM lança seu primeiro 64 bits z/Arquitetura mainframe, o Série z z900. z/Architecture é uma versão de 64 bits do 32 bits ESA/390 arquitetura, descendente dos 32 bits Sistema/360 arquitetura.
2001
A Intel envia sua linha de processadores IA-64, após repetidos atrasos na chegada ao mercado. Agora com marca Itânio e visando servidores de última geração, as vendas não atendem às expectativas.
2003
A AMD apresenta o seu Opteron e Athlon 64 linhas de processadores, com base em sua AMD64 arquitetura que é a primeira arquitetura de processador de 64 bits baseada em x86. Maçã também envia o "G5" de 64 bits PowerPC 970 CPU produzida pela IBM. A Intel afirma que seus chips Itanium continuariam sendo seus únicos processadores de 64 bits.
2004
A Intel, reagindo ao sucesso de mercado da AMD, admite que vem desenvolvendo um clone das extensões AMD64 chamado IA-32e (mais tarde renomeado EM64T, depois renomeado novamente para Intel 64). A Intel envia versões atualizadas de seus Xeon e Pêncio 4 famílias de processadores que suportam o novo conjunto de instruções de 64 bits.
Tecnologias VIA anuncia o Isaías Processador de 64 bits.[16]
2006
Sony, IBM e Toshiba começam a fabricar o 64 bits Processador de células para uso no PlayStation 3, servidores, estações de trabalho e outros aparelhos. Intel lançado Duo Core 2 como o primeiro processador x86-64 convencional para sua linha móvel, desktop e estação de trabalho. As linhas anteriores de processadores de extensão de 64 bits não estavam amplamente disponíveis no mercado de varejo de consumo (a maioria dos Pentium 4/D de 64 bits eram OEM), Pentium 4 de 64 bits, Pentium D, e a Celeron não entrou em produção em massa até o final de 2006 devido a problemas de baixo rendimento (a maioria dos wafers de bom rendimento eram direcionados a servidores e mainframes, enquanto os tradicionais ainda permanecem na linha de processadores de 130 nm e 32 bits até 2006) e logo se tornaram de baixo custo após o lançamento do Core 2. A AMD lançou seu primeiro processador móvel de 64 bits e fabricado em 90 nm.
2011
Participações ARM anuncia ARMv8-A, a primeira versão de 64 bits do Família de arquitetura ARM.[17]
2012
A ARM Holdings anunciou seus núcleos Cortex-A53 e Cortex-A57, seus primeiros núcleos baseados em sua arquitetura de 64 bits, em 30 de outubro de 2012.[18][19]
2013
A Apple anuncia o iPhone 5S, que é o primeiro processador de 64 bits em um smartphone, o A7 Sistema em um chip baseado em ARMv8-A e o iPad Air e iPad Mini 2, que são os primeiros tablets com processadores de 64 bits.
2014
RISC-V, com suporte de 32 e 64 bits, foi publicado.[20] O Google anuncia o Nexus 9 tablet, o primeiro dispositivo Android a rodar no chip Tegra K1 de 64 bits.
2015
A Apple anuncia o iPod Touch (6a geração), o primeiro iPod Touch a usar um processador de 64 bits, o A8 Sistema em um chip baseado em ARMv8-A, juntamente com o Apple TV (4a geração), a primeira Apple TV a usar um processador de 64 bits.
2018
A Apple anuncia o Apple Watch Série 4, o primeiro Apple Watch a usar um processador de 64 bits, o S4 Sistema em um chip baseado em ARMv8-A.
2020
Sinopse anuncia o ARCv3 ISA, a primeira versão de 64 bits do ARCO ISA.[21] A Apple lança o Maçã M1, que não tem suporte para aplicativos de 32 bits.
2023
Qualcomm lança o Snapdragon 8 Geração 3 e Snapdragon X Elite, que não têm suporte para aplicativos ARM de 32 bits.
Linha do tempo do sistema operacional de 64 bits
1985
Cray lançamentos UNICOS, a primeira implementação de 64 bits do Unix sistema operacional.[22]
1993
DEC lança o de 64 bits DEC OSF/1 AXP Semelhante ao Unix sistema operacional (mais tarde renomeado Tru64 UNIX) para seus sistemas baseados no Alfa arquitetura.
1994
Apoio ao R8000 processador é adicionado por Gráficos de Silício para o IRIX sistema operacional na versão 6.0.
1995
Lançamentos DEC OpenVMS 7.0, a primeira versão completa de 64 bits do OpenVMS para Alpha. Primeiro 64 bits Distribuição Linux para a arquitetura Alpha é lançada.[23]
1996
O suporte para os processadores R4x00 no modo de 64 bits é adicionado por Gráficos de Silício para o IRIX sistema operacional na versão 6.2.
1998
Sol libera Solaris 7, com 64 bits completos UltraSPARC apoiar.
2000
Lançamentos da IBM z/OS, um sistema operacional de 64 bits descendente de MVS, para o novo Série z Mainframes de 64 bits; 64 bits Linux em sistemas z segue o lançamento da CPU quase imediatamente.
2001
Linux se torna o primeiro kernel de sistema operacional a oferecer suporte total x86-64 (em um simulador, já que nenhum processador x86-64 havia sido lançado ainda).[24]
2001
Lançamentos da Microsoft Edição Windows XP de 64 bits para o Itânioarquitetura IA-64; poderia ser executado Aplicações de 32 bits através de uma camada de execução.[citação necessária]
2003
Apple lança seu Mac OS X 10.3 Sistema operacional "Panther" que adiciona suporte para aritmética inteira nativa de 64 bits PowerPC 970 processadores.[25] Vários Linux distribuições lançamento com suporte para AMD64. FreeBSD lançamentos com suporte para AMD64.
2005
Em 4 de janeiro, a Microsoft descontinuou o Windows XP 64-Bit Edition, já que nenhum PC com processadores IA-64 estava disponível desde setembro do ano anterior, e anunciou que está desenvolvendo versões x86-64 do Windows para substituí-lo.[26] Em 31 de janeiro, Sun lança Solaris 10 com suporte para processadores AMD64 e EM64T. Em 29 de abril, a Apple lança Mac OS X 10.4 "Tiger", que fornece suporte limitado para aplicativos de linha de comando de 64 bits em máquinas com processadores PowerPC 970; versões posteriores para Macs baseados em Intel suportavam aplicativos de linha de comando de 64 bits em Macs com processadores EM64T. Em 30 de abril, a Microsoft lança Windows XP Professional x64 Edição e Windows Server 2003 Edição x64 para processadores AMD64 e EM64T.[27]
2006
Lançamentos da Microsoft Windows Vista, incluindo uma versão de 64 bits para processadores AMD64/EM64T que mantém compatibilidade de 32 bits. Na versão de 64 bits, todos os aplicativos e componentes do Windows são de 64 bits, embora muitos também tenham suas versões de 32 bits incluídas para compatibilidade com plug-ins.[citação necessária]
2007
Lançamentos da Apple Mac OS X 10.5 "Leopard", que suporta totalmente aplicativos de 64 bits em máquinas com processadores PowerPC 970 ou EM64T.[citação necessária]
2009
Lançamentos da Microsoft Windows 7, que, assim como o Windows Vista, inclui uma versão completa de 64 bits para processadores AMD64/Intel 64; a maioria dos novos computadores é carregada por padrão com uma versão de 64 bits. A Microsoft também lança Windows Server 2008 R2, que é o primeiro sistema operacional de servidor somente de 64 bits. Lançamentos da Apple Mac OS X 10.6, "Snow Leopard", que vem com um kernel de 64 bits para processadores AMD64/Intel64, embora apenas alguns modelos recentes de computadores Apple executem o kernel de 64 bits por padrão. A maioria dos aplicativos incluídos no Mac OS X 10.6 agora também são de 64 bits.[25]
2010
O Windows 7 (64 bits) se torna o sistema operacional mais popular no Steam, superando o Windows XP (32 bits).[28][29]
2011
Lançamentos da Apple Mac OS X 10.7, "Lion", que executa o kernel de 64 bits por padrão em máquinas suportadas. Máquinas mais antigas que não conseguem executar o kernel de 64 bits executam o kernel de 32 bits, mas, assim como em versões anteriores, ainda podem executar aplicativos de 64 bits; o Lion não oferece suporte a máquinas com processadores de 32 bits. Quase todos os aplicativos incluídos no Mac OS X 10.7 agora também são de 64 bits, incluindo o iTunes.[citação necessária]
2012
Lançamentos da Microsoft Windows 8 que suporta UEFI Classe 3 (UEFI sem CSM) e Inicialização segura.[30] Lançamentos da Apple Leão da Montanha OS X, o que torna o kernel de 64 bits o padrão em algumas máquinas mais antigas não suportadas anteriormente e remove o kernel de 32 bits.
2013
Lançamentos da Apple iOS 7, que, em máquinas com processadores AArch64, possui um kernel de 64 bits que suporta aplicativos de 64 bits.[citação necessária]
2014
Lançamentos do Google Pirulito Android, a primeira versão do Android sistema operacional com suporte para processadores de 64 bits.[citação necessária]
2017
Lançamentos da Apple iOS 11, suportando apenas máquinas com processadores AArch64. Ele tem um kernel de 64 bits que suporta apenas aplicativos de 64 bits. Aplicativos de 32 bits não são mais compatíveis.[citação necessária]
2018
Lançamentos da Apple watchOS 5, a primeira versão do watchOS a oferecer suporte a 64 bits.[citação necessária]
2019
Lançamentos da Apple macOS 10.15 "Catalina", abandonando o suporte para aplicativos Intel de 32 bits.[citação necessária]
2021
Lançamentos da Microsoft Windows 11 em 5 de outubro, que suporta apenas sistemas de 64 bits, abandonando o suporte para sistemas IA-32 e AArch32.[citação necessária]
2022
Google lança o Pixel 7, o que elimina o suporte para aplicativos de 32 bits. Lançamentos da Apple watchOS 9, a primeira versão do watchOS a rodar exclusivamente nos modelos Apple Watch com processadores de 64 bits (incluindo Apple Watch Series 4 ou mais recente, Apple Watch SE (1a geração) ou mais recente e o recém-introduzido Apple Watch Ultra), abandonando o suporte para Apple Watch Série 3 como o modelo final do Apple Watch com processador de 32 bits.[citação necessária]
2023
Lançamentos do Google Android 14, o que elimina o suporte para aplicativos de 32 bits.
2024
Lançamentos da Microsoft Atualização do Windows 11 2024, cujas versões ARM abandonam o suporte para aplicativos ARM de 32 bits.
Limites dos processadores
Em princípio, um microprocessador de 64 bits pode endereçar 16 EB (16 × 10246 = 264 = 18.446.744.073.709.551.616 bytes) de memória. Entretanto, nem todos os conjuntos de instruções, e nem todos os processadores que implementam esses conjuntos de instruções, suportam um espaço de endereço virtual ou físico completo de 64 bits.

O Arquitetura x86-64 (em março de 2024) permite 48 bits para memória virtual e, para qualquer processador, até 52 bits para memória física.[31][32] Esses limites permitem tamanhos de memória de 256 TB (256 × 10244 bytes) e 4 PB (4 × 10245 bytes), respectivamente. Um PC não pode conter 4 no momento petabytes de memória (devido ao tamanho físico dos chips de memória), mas a AMD imaginou grandes servidores, clusters de memória compartilhada e outros usos do espaço de endereço físico que poderiam se aproximar disso em um futuro próximo. Dessa forma, o endereço físico de 52 bits oferece amplo espaço para expansão sem incorrer no custo de implementação de endereços físicos completos de 64 bits. Da mesma forma, o espaço de endereço virtual de 48 bits foi projetado para fornecer 65.536 (216) vezes o limite de 32 bits de 4 GB (4 × 10243 bytes), permitindo espaço para expansão posterior e não incorrendo em sobrecarga na tradução de endereços completos de 64 bits.

O Power ISA v3.0 permite 64 bits para um endereço efetivo, mapeado para um endereço segmentado com entre 65 e 78 bits permitidos, para memória virtual e, para qualquer processador, até 60 bits para memória física.[33]

O Oráculo SPARC O Architecture 2015 permite 64 bits para memória virtual e, para qualquer processador, entre 40 e 56 bits para memória física.[34]

O BRAÇO AArch64 A Arquitetura do Sistema de Memória Virtual permite de 48 a 56 bits para memória virtual e, para qualquer processador, de 32 a 56 bits para memória física.[35]

O DEC Alfa a especificação requer que no mínimo 43 bits de espaço de endereço de memória virtual (8 TB) sejam suportados, e o hardware precisa verificar e capturar se os bits restantes não suportados são zero (para oferecer suporte à compatibilidade em processadores futuros). Alfa 21064 suportava 43 bits de espaço de endereço de memória virtual (8 TB) e 34 bits de espaço de endereço de memória física (16 GB). Alfa 21164 suportava 43 bits de espaço de endereço de memória virtual (8 TB) e 40 bits de espaço de endereço de memória física (1 TB). Alfa 21264 suportava 43 ou 48 bits de espaço de endereço de memória virtual configuráveis pelo usuário (8 TB ou 256 TB) e 44 bits de espaço de endereço de memória física (16 TB).

Aplicações de 64 bits
32 bits vs 64 bits
Uma mudança de a 32 bits para uma arquitetura de 64 bits é uma alteração fundamental, como a maioria sistemas operacionais deve ser amplamente modificado para aproveitar as vantagens da nova arquitetura, porque esse software precisa gerenciar o hardware real de endereçamento de memória.[36] Outro software também deve ser portado para usar as novas habilidades; softwares mais antigos de 32 bits podem ser suportados em virtude do conjunto de instruções de 64 bits ser um superconjunto do conjunto de instruções de 32 bits, de modo que os processadores que suportam o conjunto de instruções de 64 bits também possam executar código para o conjunto de instruções de 32 bits ou por meio de software emulação, ou pela implementação real de um núcleo de processador de 32 bits dentro do processador de 64 bits, como acontece com alguns Itânio processadores da Intel, que incluíam um IA-32 núcleo do processador para executar 32 bits x86 aplicações. Os sistemas operacionais para essas arquiteturas de 64 bits geralmente suportam aplicativos de 32 e 64 bits.[37]

Uma exceção significativa a isso é a IBM AS/400, software para o qual é compilado em um virtual arquitetura do conjunto de instruções (ISA) chamado Interface de máquina independente de tecnologia (TIMI); O código TIMI é então traduzido para código de máquina nativo por software de baixo nível antes de ser executado. O software de tradução é tudo o que deve ser reescrito para mover todo o sistema operacional e todo o software para uma nova plataforma, como quando a IBM fez a transição do conjunto de instruções nativas para AS/400 do antigo sistema de 32/48 bits IMPI para o mais novo 64 bits PowerPC-AS, codinome Amazon. O conjunto de instruções IMPI era bem diferente até mesmo do PowerPC de 32 bits, então essa transição era ainda maior do que mover um determinado conjunto de instruções de 32 para 64 bits.

Em hardware de 64 bits com x86-64 arquitetura (AMD64), a maioria dos sistemas operacionais e aplicativos de 32 bits podem ser executados sem problemas de compatibilidade. Enquanto o maior espaço de endereço das arquiteturas de 64 bits torna possível trabalhar com grandes conjuntos de dados em aplicações como vídeo digital, computação científica e grande bases de dados mais fácil, tem havido um debate considerável sobre se eles ou seus 32 bits modos de compatibilidade será mais rápido do que sistemas de 32 bits com preços comparáveis para outras tarefas.

Um programa Java compilado pode ser executado em uma máquina virtual Java de 32 ou 64 bits sem nenhuma modificação. Os comprimentos e a precisão de todos os tipos integrados, como char, short, int, long, float, e double, e os tipos que podem ser usados como índices de matriz são especificados pelo padrão e não dependem da arquitetura subjacente. Programas Java executados em uma máquina virtual Java de 64 bits têm acesso a um espaço de endereço maior.[38]

A velocidade não é o único fator a considerar na comparação de processadores de 32 e 64 bits. Aplicações como multitarefa, teste de estresse e agrupamento – para computação de alto desempenho (HPC) – pode ser mais adequado para uma arquitetura de 64 bits quando implantado adequadamente. Por esse motivo, clusters de 64 bits têm sido amplamente implantados em grandes organizações, como IBM, HP e Microsoft.

Resumo:

Um processador de 64 bits tem melhor desempenho com software de 64 bits.
Um processador de 64 bits pode ter compatibilidade com versões anteriores, permitindo que ele execute software aplicativo de 32 bits para a versão de 32 bits de seu conjunto de instruções e também pode suportar a execução de sistemas operacionais de 32 bits para a versão de 32 bits de seu conjunto de instruções.
Um processador de 32 bits é incompatível com software de 64 bits.
Prós e contras
Um equívoco comum é que arquiteturas de 64 bits não são melhores do que arquiteturas de 32 bits, a menos que o computador tenha mais de 4 GB de memória de acesso aleatório.[39] Isto não é inteiramente verdade:

Alguns sistemas operacionais e certas configurações de hardware limitam o espaço de memória física a 3 GB IA-32 sistemas, devido a grande parte da região de 3–4 GB ser reservada para endereçamento de hardware; veja Barreira de 3 GB; Arquiteturas de 64 bits podem endereçar muito mais de 4 GB. No entanto, os processadores IA-32 do Pentium Pro permitir posteriormente um de 36 bits físico espaço de endereço de memória, usando Extensão de endereço físico (PAE), que fornece um intervalo de endereços físicos de 64 GB, dos quais até 62 GB podem ser usados pela memória principal; sistemas operacionais que suportam PAE não podem ser limitados a 4 GB de memória física, mesmo em processadores IA-32. No entanto, drivers e outros softwares de modo kernel, principalmente versões mais antigas, podem ser incompatíveis com o PAE; isso foi citado como o motivo das versões de 32 bits do Microsoft Windows sendo limitado a 4 GB de RAM física[40] (embora a validade desta explicação tenha sido contestada[41]).
Alguns sistemas operacionais reservam partes de processo espaço de endereço para uso do sistema operacional, reduzindo efetivamente o espaço total de endereços disponível para memória de mapeamento para programas de usuário. Por exemplo, o Windows de 32 bits reserva 1 ou 2 GB (dependendo das configurações) do espaço de endereço total do kernel, o que deixa apenas 3 ou 2 GB (respectivamente) do espaço de endereço disponível para o modo de usuário. Esse limite é muito maior em sistemas operacionais de 64 bits.
Arquivos mapeados em memória estão se tornando mais difíceis de implementar em arquiteturas de 32 bits, pois arquivos com mais de 4 GB se tornam mais comuns; arquivos tão grandes não podem ser mapeados facilmente na memória para arquiteturas de 32 bits, pois apenas parte do arquivo pode ser mapeada no espaço de endereço por vez, e para acessar esse arquivo por mapeamento de memória, as partes mapeadas devem ser trocadas para dentro e para fora do espaço de endereço, conforme necessário. Isso é um problema, pois o mapeamento de memória, se implementado corretamente pelo sistema operacional, é um dos métodos de disco para memória mais eficientes.
Alguns programas de 64 bits, como codificadores, decodificadores e software de criptografia, podem se beneficiar muito dos registradores de 64 bits,[citação necessária] enquanto o desempenho de outros programas, como os voltados para gráficos 3D, permanece inalterado ao alternar de um ambiente de 32 bits para um de 64 bits.[citação necessária]
Algumas arquiteturas de 64 bits, como x86-64 e AArch64, suportam mais registradores de uso geral do que seus equivalentes de 32 bits (embora isso não se deva especificamente ao comprimento da palavra). Isto leva a um aumento significativo de velocidade para loops apertados, uma vez que o processador não precisa buscar dados do cache ou da memória principal se os dados couberem nos registros disponíveis.
Exemplo em C:
intum,b,c,dd,e;para(um=0;um<100;um++){b=um;c=b;dd=c;e=dd;}     
        
      
      
      
      

Este código primeiro cria 5 valores: a, b, c, d e e; e então os coloca em um loop. Durante o loop, esse código altera o valor de b para o valor de a, o valor de c para o valor de b, o valor de d para o valor de c e o valor de e para o valor de d. Isso tem o mesmo efeito que alterar todos os valores para a.
Se um processador puder manter apenas dois ou três valores ou variáveis em registradores, ele precisará mover alguns valores entre a memória e os registradores para poder processar também as variáveis d e e; este é um processo que leva muitos ciclos de CPU. Um processador que pode armazenar todos os valores e variáveis em registradores pode percorrê-los sem a necessidade de mover dados entre registradores e memória para cada iteração. Esse comportamento pode ser facilmente comparado com a memória virtual, embora quaisquer efeitos dependam do compilador.
A principal desvantagem das arquiteturas de 64 bits é que, em relação às arquiteturas de 32 bits, os mesmos dados ocupam mais espaço na memória (devido a ponteiros mais longos e possivelmente outros tipos, e preenchimento de alinhamento). Isso aumenta os requisitos de memória de um determinado processo e pode ter implicações para o uso eficiente do cache do processador. Manter um modelo parcial de 32 bits é uma maneira de lidar com isso e, em geral, é razoavelmente eficaz. Por exemplo, o z/OSO sistema operacional adota essa abordagem, exigindo que o código do programa resida em espaços de endereço de 31 bits (o bit de ordem superior não é usado no cálculo de endereço na plataforma de hardware subjacente), enquanto os objetos de dados podem residir opcionalmente em regiões de 64 bits. Nem todos esses aplicativos exigem um grande espaço de endereço ou manipulam itens de dados de 64 bits, portanto, esses aplicativos não se beneficiam desses recursos.

Disponibilidade de software
Os sistemas de 64 bits baseados em x86 às vezes não possuem equivalentes de software que é escrito para arquiteturas de 32 bits. O problema mais grave no Microsoft Windows é incompatível drivers de dispositivo para hardware obsoleto. A maioria dos softwares aplicativos de 32 bits pode ser executada em um sistema operacional de 64 bits em um modo de compatibilidade, também denominado emulação modo, por exemplo, Microsoft WoW64 Tecnologia para IA-64 e AMD64. O modo nativo do Windows de 64 bits[42] o ambiente do driver é executado em cima de 64 bits NTDLL.DLL, que não pode chamar código de subsistema Win32 de 32 bits (geralmente dispositivos cuja função de hardware real é emulada em software de modo de usuário, como Winprinters). Como os drivers de 64 bits para a maioria dos dispositivos não estavam disponíveis até o início de 2007 (Vista x64), usar uma versão de 64 bits do Windows foi considerado um desafio. No entanto, desde então, a tendência mudou para a computação de 64 bits, ainda mais à medida que os preços da memória caíram e o uso de mais de 4 GB de RAM aumentou. A maioria dos fabricantes começou a fornecer drivers de 32 e 64 bits para novos dispositivos, então a indisponibilidade de drivers de 64 bits deixou de ser um problema. Drivers de 64 bits não foram fornecidos para muitos dispositivos mais antigos, que consequentemente não podiam ser usados em sistemas de 64 bits.

A compatibilidade de drivers era um problema menor com drivers de código aberto, pois os de 32 bits podiam ser modificados para uso em 64 bits. O suporte para hardware fabricado antes do início de 2007 era problemático para plataformas de código aberto[citação necessária] devido ao número relativamente pequeno de usuários.

Versões de 64 bits do Windows não podem ser executadas Software de 16 bits. No entanto, a maioria dos aplicativos de 32 bits funcionará bem. Os usuários de 64 bits são forçados a instalar um máquina virtual de um sistema operacional de 16 ou 32 bits para executar aplicativos de 16 bits ou usar uma das alternativas para NTVDM.[43]

Mac OS X 10.4 "Tigre" e Mac OS X 10.5 "Leopard" tinha apenas um kernel de 32 bits, mas eles podem executar código de modo de usuário de 64 bits em processadores de 64 bits. Mac OS X 10.6 O "Snow Leopard" tinha kernels de 32 e 64 bits e, na maioria dos Macs, usava o kernel de 32 bits, mesmo em processadores de 64 bits. Isso permitiu que esses Macs suportassem processos de 64 bits e ainda suportassem drivers de dispositivo de 32 bits; embora não drivers de 64 bits e vantagens de desempenho que podem vir com eles. Mac OS X 10.7 "Lion" rodava com um kernel de 64 bits em mais Macs e OS X 10.8 "Leão da Montanha" e mais tarde macOSas versões possuem apenas um kernel de 64 bits. Em sistemas com processadores de 64 bits, os kernels do macOS de 32 e 64 bits podem executar código de modo de usuário de 32 bits, e todas as versões do macOS até o macOS Mojave (10.14) incluem versões de 32 bits de bibliotecas que os aplicativos de 32 bits usariam, portanto, o software de modo de usuário de 32 bits para macOS será executado nesses sistemas. As versões de 32 bits das bibliotecas foram removidas pela Apple no macOS Catalina (10.15).

Linux e a maioria dos outros Semelhante ao Unix sistemas operacionais e o C e C++ cadeias de ferramentas para eles, suportam processadores de 64 bits há muitos anos. Muitos aplicativos e bibliotecas para essas plataformas são software de código aberto, escritos em C e C++, para que, se forem seguros para 64 bits, possam ser compilados em versões de 64 bits. Esse modelo de distribuição baseado em fonte, com ênfase em lançamentos frequentes, torna a disponibilidade de software aplicativo para esses sistemas operacionais menos problemática.

Modelos de dados de 64 bits
Em programas de 32 bits, ponteiros e tipos de dados como números inteiros geralmente têm o mesmo comprimento. Isso não é necessariamente verdade em máquinas de 64 bits.[44][45][46] Mistura de tipos de dados em linguagens de programação como C e seus descendentes, como C++ e Objetivo-C pode, portanto, funcionar em implementações de 32 bits, mas não em implementações de 64 bits.

Em muitos ambientes de programação para linguagens C e derivadas de C em máquinas de 64 bits, int as variáveis ainda têm 32 bits de largura, mas os inteiros longos e os ponteiros têm 64 bits de largura. Estes são descritos como tendo um LP64 modelo de dados, que é uma abreviatura de "Long, Pointer, 64".[47][48] Outros modelos são os ILP64 modelo de dados em que todos os três tipos de dados têm 64 bits de largura,[49][48] e até mesmo o SILP64 modelo onde curto os inteiros também têm 64 bits de largura.[50][51] Entretanto, na maioria dos casos, as modificações necessárias são relativamente pequenas e diretas, e muitos programas bem escritos podem ser simplesmente recompilados para o novo ambiente sem alterações. Outra alternativa é a LLP64 modelo, que mantém a compatibilidade com o código de 32 bits, deixando ambos int e long como 32 bits.[52][48] LL refere-se ao inteiro longo longo tipo, que tem pelo menos 64 bits em todas as plataformas, incluindo ambientes de 32 bits.

Existem também sistemas com processadores de 64 bits usando um ILP32 modelo de dados, com a adição de inteiros longos de 64 bits; isso também é usado em muitas plataformas com processadores de 32 bits. Este modelo reduz o tamanho do código e o tamanho das estruturas de dados que contêm ponteiros, ao custo de um espaço de endereço muito menor, uma boa escolha para alguns sistemas embarcados. Para conjuntos de instruções como x86 e ARM, nos quais a versão de 64 bits do conjunto de instruções tem mais registradores do que a versão de 32 bits, ele fornece acesso aos registradores adicionais sem penalidade de espaço. É comum em máquinas RISC de 64 bits,[citação necessária] explorado em x86 como x32 ABI, e tem sido usado recentemente no Apple Watch Série 4 e 5.[53][54]

Modelos de dados de 64 bits
Dados
modelo	curtoint
int	longoint
longo
longo	Ponteiro,tamanho_t
Sistemas operacionais de amostra
ILP32	16	32	32	64	32	x32 e braço64ilp32 ABIs em sistemas Linux; MIPS N32 ABI.
LLP64	16	32	32	64	64	Microsoft Windows (x86-64, IA-64 e ARM64) usando Visual C++; e MinGW
LP64	16	32	64	64	64	A maioria Unix e Semelhante ao Unix sistemas, por exemplo, Solaris, Linux, BSD, macOS. Windows ao usar Cigwin; z/OS
ILP64	16	64	64	64	64	Sistemas de Computador HAL porto de Solaris para o SPARC64
SILP64	64	64	64	64	64	Clássico UNICOS[50][51] (versus UNICOS/mp, etc.)
Muitas plataformas de 64 bits hoje usam um LP64 modelo (incluindo Solaris, AIX, HP-UX, Linux, macOS, BSD e IBM z/OS). O Microsoft Windows usa um LLP64 modelo. A desvantagem do modelo LP64 é que armazenar um long em um int trunca. Por outro lado, converter um ponteiro em a long "funcionará" no LP64. No modelo LLP64, o inverso é verdadeiro. Esses não são problemas que afetam o código totalmente compatível com os padrões, mas o código geralmente é escrito com suposições implícitas sobre as larguras dos tipos de dados. O código C deve preferir (u)intptr_t em vez de long ao converter ponteiros em objetos inteiros.

Um modelo de programação é uma escolha feita para se adequar a um determinado compilador, e vários podem coexistir no mesmo sistema operacional. No entanto, o modelo de programação escolhido como modelo primário para o sistema operacional interface de programação de aplicativos (API) normalmente domina.

Outra consideração é o modelo de dados utilizado para drivers de dispositivo. Os drivers constituem a maior parte do código do sistema operacional na maioria dos sistemas operacionais modernos[citação necessária] (embora muitos possam não ser carregados quando o sistema operacional estiver em execução). Muitos drivers usam ponteiros intensamente para manipular dados e, em alguns casos, precisam carregar ponteiros de um determinado tamanho no hardware que suportam acesso direto à memória (DMA). Por exemplo, um driver para um dispositivo PCI de 32 bits solicitando ao dispositivo dados DMA em áreas superiores da memória de uma máquina de 64 bits não conseguiu satisfazer as solicitações do sistema operacional para carregar dados do dispositivo para a memória acima dos 4 gigabyte barreira, porque os ponteiros para esses endereços não caberiam nos registros DMA do dispositivo. Este problema é resolvido fazendo com que o sistema operacional leve em consideração as restrições de memória do dispositivo ao gerar solicitações aos drivers para DMA ou usando um unidade de gerenciamento de memória de entrada–saída (IOMMU).

Arquiteturas atuais de 64 bits
ícone
Esta seção não citar qualquer fontes. Por favor ajude melhore esta seção por adicionando citações a fontes confiáveis. Material sem fontes pode ser contestado e removido. (Abril de 2023) (Saiba como e quando remover esta mensagem)
Em agosto de 2023, As arquiteturas de 64 bits para as quais os processadores foram fabricados incluíam:

A extensão de 64 bits criada por Microdispositivos avançados (AMD) para a Intel x86 arquitetura (posteriormente licenciada pela Intel); comumente denominada x86-64, AMD64, ou x64:
AMD's AMD64 extensões (usadas em Athlon 64, Opteron, Sempron, Turião 64, Fenômeno, Atlon II, Fenômeno II, APU, FX, Ryzen, e Epic processadores)
Intel's Intel 64 extensões, usadas em Núcleo Intel 2/i3/i5/i7/i9, alguns Átomo, e mais recentes Celeron, Pentium, e Xeon processadores
Intelarquitetura K1OM, uma variante de Intel 64 sem instruções CMOV, MMX e SSE, usadas na primeira geração Xeon Phi (Knights Corner) coprocessadores, binários incompatíveis com programas x86-64
Tecnologias VIA' Extensões de 64 bits, usadas no VIA Nano processadores
Participações ARM' AArch64 arquitetura
IBM's PowerPC/Poder ISA:
IBM's Potência10 processador e predecessores, e o IBM A2 processadores
IBM's z/Arquitetura, uma versão de 64 bits do ESA/390 arquitetura, usada na IBM IBM Z mainframes:
IBM Telum Processador II e antecessores
Hitachi AP8000E
RISC-V
SPARC Arquitetura V9:
OráculoProcessadores e predecessores M8 e S7
Fujitsu's SPARC64 XII e SPARC64 XIfx processadores e predecessores
Tecnologias MIPS' MIPS64 arquitetura
Arquitetura NEC SX
SX-Aurora TSUBASA
Elbrus arquitetura:
Elbrus-8S
ARCO
A maioria das arquiteturas de 64 bits derivadas de uma versão de 32 bits da mesma arquitetura pode executar código escrito nativamente para a versão de 32 bits, sem penalidade de desempenho. Por exemplo, os processadores x86-64 podem ser executados IA-32 aplicações a toda velocidade.[55] Esse tipo de suporte é comumente chamado suporte bi-arco ou de forma mais geral suporte multi-arco.

